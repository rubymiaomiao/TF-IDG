{
    "sourceFile": "datasets/data_utils.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1754658546396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1754658569216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,674 @@\n+import numpy as np\n+import torch \n+import cv2\n+\n+def generate_mask_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n+    # 确保 ref_mask_compose 是二维的\n+    if len(ref_mask_compose.shape) == 3:\n+        ref_mask_compose = ref_mask_compose[:,:,0]\n+    \n+    # 将 ref_mask_compose 转换为布尔掩码\n+    ref_mask_bool = ref_mask_compose > 128\n+\n+    # 创建一个与 cropped_target_image 相同大小的空白图像\n+    ref_image_collage = cropped_target_image.copy()\n+\n+    # 获取目标区域的尺寸\n+    y1, y2, x1, x2 = tar_box_yyxx\n+    \n+    \n+    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n+    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n+    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n+    resized_ref_image = np.zeros((resized_ref_image.shape[0], resized_ref_image.shape[1], 3), dtype=np.uint8)\n+\n+    # 将调整大小后的参考图像的前景部分复制到目标区域\n+    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n+\n+    return ref_image_collage\n+\n+def generate_ref_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n+    # 确保 ref_mask_compose 是二维的\n+    if len(ref_mask_compose.shape) == 3:\n+        ref_mask_compose = ref_mask_compose[:,:,0]\n+    \n+    # 将 ref_mask_compose 转换为布尔掩码\n+    ref_mask_bool = ref_mask_compose > 128\n+\n+    # 创建一个与 cropped_target_image 相同大小的空白图像\n+    ref_image_collage = cropped_target_image.copy()\n+\n+    # 获取目标区域的尺寸\n+    y1, y2, x1, x2 = tar_box_yyxx\n+    \n+    \n+    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n+    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n+    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n+\n+    # 将调整大小后的参考图像的前景部分复制到目标区域\n+    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n+\n+    return ref_image_collage\n+\n+def mask_score(mask):\n+    '''Scoring the mask according to connectivity.'''\n+    mask = mask.astype(np.uint8)\n+    if mask.sum() < 10:\n+        return 0\n+    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n+    cnt_area = [cv2.contourArea(cnt) for cnt in contours]\n+    conc_score = np.max(cnt_area) / sum(cnt_area)\n+    return conc_score\n+\n+\n+def sobel(img, mask, thresh = 1):\n+    '''Calculating the high-frequency map.'''\n+    H,W = img.shape[0], img.shape[1]\n+    img = cv2.resize(img,(256,256))\n+    mask = (cv2.resize(mask,(256,256)) > 0.5).astype(np.uint8)\n+    kernel = np.ones((5,5),np.uint8)\n+    mask = cv2.erode(mask, kernel, iterations = 2)\n+    \n+    Ksize = 3\n+    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n+    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n+    sobel_X = cv2.convertScaleAbs(sobelx)\n+    sobel_Y = cv2.convertScaleAbs(sobely)\n+    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n+    scharr = np.max(scharr,-1) * mask    \n+    \n+    scharr[scharr < thresh] = 0.0\n+    scharr = np.stack([scharr,scharr,scharr],-1)\n+    scharr = (scharr.astype(np.float32)/255 * img.astype(np.float32) ).astype(np.uint8)\n+    scharr = cv2.resize(scharr,(W,H))\n+    return scharr\n+\n+\n+def resize_and_pad(image, box):\n+    '''Fitting an image to the box region while keeping the aspect ratio.'''\n+    y1,y2,x1,x2 = box\n+    H,W = y2-y1, x2-x1\n+    h,w =  image.shape[0], image.shape[1]\n+    r_box = W / H \n+    r_image = w / h\n+    if r_box >= r_image:\n+        h_target = H\n+        w_target = int(w * H / h) \n+        image = cv2.resize(image, (w_target, h_target))\n+\n+        w1 = (W - w_target) // 2\n+        w2 = W - w_target - w1\n+        pad_param = ((0,0),(w1,w2),(0,0))\n+        image = np.pad(image, pad_param, 'constant', constant_values=255)\n+    else:\n+        w_target = W \n+        h_target = int(h * W / w)\n+        image = cv2.resize(image, (w_target, h_target))\n+\n+        h1 = (H-h_target) // 2 \n+        h2 = H - h_target - h1\n+        pad_param =((h1,h2),(0,0),(0,0))\n+        image = np.pad(image, pad_param, 'constant', constant_values=255)\n+    return image\n+\n+\n+\n+def expand_image_mask(image, mask, ratio=1.4):\n+    h,w = image.shape[0], image.shape[1]\n+    H,W = int(h * ratio), int(w * ratio) \n+    h1 = int((H - h) // 2)\n+    h2 = H - h - h1\n+    w1 = int((W -w) // 2)\n+    w2 = W -w - w1\n+\n+    pad_param_image = ((h1,h2),(w1,w2),(0,0))\n+    pad_param_mask = ((h1,h2),(w1,w2))\n+    image = np.pad(image, pad_param_image, 'constant', constant_values=255)\n+    mask = np.pad(mask, pad_param_mask, 'constant', constant_values=0)\n+    return image, mask\n+\n+\n+def resize_box(yyxx, H,W,h,w):\n+    y1,y2,x1,x2 = yyxx\n+    y1,y2 = int(y1/H * h), int(y2/H * h)\n+    x1,x2 = int(x1/W * w), int(x2/W * w)\n+    y1,y2 = min(y1,h), min(y2,h)\n+    x1,x2 = min(x1,w), min(x2,w)\n+    return (y1,y2,x1,x2)\n+\n+\n+def get_bbox_from_mask(mask):\n+    h,w = mask.shape[0],mask.shape[1]\n+    if mask.sum() < 10:\n+        print(f\"mask is small,h:{h},w:{w}\")\n+        return 0,h,0,w\n+    rows = np.any(mask,axis=1)\n+    cols = np.any(mask,axis=0)\n+    y1,y2 = np.where(rows)[0][[0,-1]]\n+    x1,x2 = np.where(cols)[0][[0,-1]]\n+    return (y1,y2,x1,x2)\n+\n+\n+def expand_bbox(mask,yyxx,ratio=[1.2,2.0], min_crop=0):\n+    y1,y2,x1,x2 = yyxx\n+    ratio = np.random.randint( ratio[0] * 10,  ratio[1] * 10 ) / 10\n+    H,W = mask.shape[0], mask.shape[1]\n+    xc, yc = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n+    h = ratio * (y2-y1+1)\n+    w = ratio * (x2-x1+1)\n+    h = max(h,min_crop)\n+    w = max(w,min_crop)\n+\n+    x1 = int(xc - w * 0.5)\n+    x2 = int(xc + w * 0.5)\n+    y1 = int(yc - h * 0.5)\n+    y2 = int(yc + h * 0.5)\n+\n+    x1 = max(0,x1)\n+    x2 = min(W,x2)\n+    y1 = max(0,y1)\n+    y2 = min(H,y2)\n+    return (y1,y2,x1,x2)\n+\n+\n+def box2squre(image, box):\n+    H,W = image.shape[0], image.shape[1]\n+    y1,y2,x1,x2 = box\n+    cx = (x1 + x2) // 2\n+    cy = (y1 + y2) // 2\n+    h,w = y2-y1, x2-x1\n+\n+    if h >= w:\n+        x1 = cx - h//2\n+        x2 = cx + h//2\n+    else:\n+        y1 = cy - w//2\n+        y2 = cy + w//2\n+    x1 = max(0,x1)\n+    x2 = min(W,x2)\n+    y1 = max(0,y1)\n+    y2 = min(H,y2)\n+    return (y1,y2,x1,x2)\n+\n+\n+def pad_to_square(image, pad_value = 255, random = False):\n+    H,W = image.shape[0], image.shape[1]\n+    if H == W:\n+        return image\n+\n+    padd = abs(H - W)\n+    if random:\n+        padd_1 = int(np.random.randint(0,padd))\n+    else:\n+        padd_1 = int(padd / 2)\n+    padd_2 = padd - padd_1\n+\n+    if H > W:\n+        pad_param = ((0,0),(padd_1,padd_2),(0,0))\n+    else:\n+        pad_param = ((padd_1,padd_2),(0,0),(0,0))\n+\n+    image = np.pad(image, pad_param, 'constant', constant_values=pad_value)\n+    return image\n+\n+\n+\n+def box_in_box(small_box, big_box):\n+    y1,y2,x1,x2 = small_box\n+    y1_b, _, x1_b, _ = big_box\n+    y1,y2,x1,x2 = y1 - y1_b ,y2 - y1_b, x1 - x1_b ,x2 - x1_b\n+    return (y1,y2,x1,x2 )\n+\n+\n+\n+def shuffle_image(image, N):\n+    height, width = image.shape[:2]\n+    \n+    block_height = height // N\n+    block_width = width // N\n+    blocks = []\n+    \n+    for i in range(N):\n+        for j in range(N):\n+            block = image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width]\n+            blocks.append(block)\n+    \n+    np.random.shuffle(blocks)\n+    shuffled_image = np.zeros((height, width, 3), dtype=np.uint8)\n+\n+    for i in range(N):\n+        for j in range(N):\n+            shuffled_image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = blocks[i*N+j]\n+    return shuffled_image\n+\n+\n+def get_mosaic_mask(image, fg_mask, N=16, ratio = 0.5):\n+    ids = [i for i in range(N * N)]\n+    masked_number = int(N * N * ratio)\n+    masked_id = np.random.choice(ids, masked_number, replace=False)\n+    \n+\n+    \n+    height, width = image.shape[:2]\n+    mask = np.ones((height, width))\n+    \n+    block_height = height // N\n+    block_width = width // N\n+    \n+    b_id = 0\n+    for i in range(N):\n+        for j in range(N):\n+            if b_id in masked_id:\n+                mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] * 0\n+            b_id += 1\n+    mask = mask * fg_mask\n+    mask3 = np.stack([mask,mask,mask],-1).copy().astype(np.uint8)\n+    noise = q_x(image)\n+    noise_mask = image * mask3 + noise * (1-mask3)\n+    return noise_mask\n+\n+def extract_canney_noise(image, mask, dilate=True):\n+    h,w = image.shape[0],image.shape[1]\n+    mask = cv2.resize(mask.astype(np.uint8),(w,h)) > 0.5\n+    kernel = np.ones((8, 8), dtype=np.uint8)\n+    mask =  cv2.erode(mask.astype(np.uint8), kernel, 10)\n+\n+    canny = cv2.Canny(image, 50,100) * mask\n+    kernel = np.ones((8, 8), dtype=np.uint8)\n+    mask = (cv2.dilate(canny, kernel, 5) > 128).astype(np.uint8)\n+    mask = np.stack([mask,mask,mask],-1)\n+\n+    pure_noise = q_x(image, t=1) * 0 + 255\n+    canny_noise = mask * image + (1-mask) * pure_noise\n+    return canny_noise\n+\n+\n+def get_random_structure(size):\n+    choice = np.random.randint(1, 5)\n+\n+    if choice == 1:\n+        return cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))\n+    elif choice == 2:\n+        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size))\n+    elif choice == 3:\n+        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size//2))\n+    elif choice == 4:\n+        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size//2, size))\n+\n+def random_dilate(seg, min=3, max=10):\n+    size = np.random.randint(min, max)\n+    kernel = get_random_structure(size)\n+    seg = cv2.dilate(seg,kernel,iterations = 1)\n+    return seg\n+\n+def random_erode(seg, min=3, max=10):\n+    size = np.random.randint(min, max)\n+    kernel = get_random_structure(size)\n+    seg = cv2.erode(seg,kernel,iterations = 1)\n+    return seg\n+\n+def compute_iou(seg, gt):\n+    intersection = seg*gt\n+    union = seg+gt\n+    return (np.count_nonzero(intersection) + 1e-6) / (np.count_nonzero(union) + 1e-6)\n+\n+\n+def select_max_region(mask):\n+    nums, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n+    background = 0\n+    for row in range(stats.shape[0]):\n+        if stats[row, :][0] == 0 and stats[row, :][1] == 0:\n+            background = row\n+    stats_no_bg = np.delete(stats, background, axis=0)\n+    max_idx = stats_no_bg[:, 4].argmax()\n+    max_region = np.where(labels==max_idx+1, 1, 0)\n+\n+    return max_region.astype(np.uint8)\n+\n+\n+\n+def perturb_mask(gt, min_iou = 0.3,  max_iou = 0.99):\n+    iou_target = np.random.uniform(min_iou, max_iou)\n+    h, w = gt.shape\n+    gt = gt.astype(np.uint8)\n+    seg = gt.copy()\n+    \n+    # Rare case\n+    if h <= 2 or w <= 2:\n+        print('GT too small, returning original')\n+        return seg\n+\n+    # Do a bunch of random operations\n+    for _ in range(250):\n+        for _ in range(4):\n+            lx, ly = np.random.randint(w), np.random.randint(h)\n+            lw, lh = np.random.randint(lx+1,w+1), np.random.randint(ly+1,h+1)\n+\n+            # Randomly set one pixel to 1/0. With the following dilate/erode, we can create holes/external regions\n+            if np.random.rand() < 0.1:\n+                cx = int((lx + lw) / 2)\n+                cy = int((ly + lh) / 2)\n+                seg[cy, cx] = np.random.randint(2) * 255\n+\n+            # Dilate/erode\n+            if np.random.rand() < 0.5:\n+                seg[ly:lh, lx:lw] = random_dilate(seg[ly:lh, lx:lw])\n+            else:\n+                seg[ly:lh, lx:lw] = random_erode(seg[ly:lh, lx:lw])\n+            \n+            seg = np.logical_or(seg, gt).astype(np.uint8)\n+            #seg = select_max_region(seg) \n+\n+        if compute_iou(seg, gt) < iou_target:\n+            break\n+    seg = select_max_region(seg.astype(np.uint8)) \n+    return seg.astype(np.uint8)\n+\n+\n+def q_x(x_0,t=65):\n+    '''Adding noise for and given image.'''\n+    x_0 = torch.from_numpy(x_0).float() / 127.5 - 1\n+    num_steps = 100\n+    \n+    betas = torch.linspace(-6,6,num_steps)\n+    betas = torch.sigmoid(betas)*(0.5e-2 - 1e-5)+1e-5\n+\n+    alphas = 1-betas\n+    alphas_prod = torch.cumprod(alphas,0)\n+    \n+    alphas_prod_p = torch.cat([torch.tensor([1]).float(),alphas_prod[:-1]],0)\n+    alphas_bar_sqrt = torch.sqrt(alphas_prod)\n+    one_minus_alphas_bar_log = torch.log(1 - alphas_prod)\n+    one_minus_alphas_bar_sqrt = torch.sqrt(1 - alphas_prod)\n+    \n+    noise = torch.randn_like(x_0)\n+    alphas_t = alphas_bar_sqrt[t]\n+    alphas_1_m_t = one_minus_alphas_bar_sqrt[t]\n+    return (alphas_t * x_0 + alphas_1_m_t * noise).numpy()  * 127.5 + 127.5 \n+\n+\n+def extract_target_boundary(img, target_mask):\n+    Ksize = 3\n+    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n+    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n+\n+    # sobel-x\n+    sobel_X = cv2.convertScaleAbs(sobelx)\n+    # sobel-y\n+    sobel_Y = cv2.convertScaleAbs(sobely)\n+    # sobel-xy\n+    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n+    scharr = np.max(scharr,-1).astype(np.float32)/255\n+    scharr = scharr *  target_mask.astype(np.float32)\n+    return scharr\n+\n+\n+#===============================================================================\n+\n+def preprocess_image(img, target_shape):\n+    h, w = target_shape\n+\n+    # Resize to target shape\n+    if img.shape[:2] != (h, w):\n+        img = cv2.resize(img, (w, h))\n+\n+    # If shape is (h, w) or (h, w, 1), convert to 3 channels\n+    if len(img.shape) == 2:\n+        img = np.stack([img] * 3, axis=-1)\n+    elif img.shape[2] == 1:\n+        img = np.concatenate([img] * 3, axis=-1)\n+\n+    # Scale if float (like ref_processed which might be [0, 1])\n+    if img.dtype != np.uint8:\n+        img = (img * 255).clip(0, 255).astype(np.uint8)\n+\n+    return img\n+def compose_images(ref_image, ref_mask, gt_image, tar_mask, synthesis, ref_processed):\n+    h, w = ref_image.shape[:2]\n+    grid = np.zeros((h*2, w*3, 3), dtype=np.uint8)\n+    if ref_processed.shape[:2] != (h, w):\n+        ref_processed = cv2.resize(ref_processed, (w, h))\n+    \n+    images = [ref_image, ref_mask[:,:,None]*255, gt_image,\n+              tar_mask[:,:,None]*255, ref_processed*255, synthesis]\n+    positions = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2)]\n+    \n+    for img, (i, j) in zip(images, positions):\n+        grid[i*h:(i+1)*h, j*w:(j+1)*w] = img\n+    \n+    return grid\n+\n+\n+def get_connected_components(mask):\n+    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n+    components = []\n+    for i in range(1, num_labels):  \n+        component_mask = (labels == i).astype(np.uint8)\n+        components.append(component_mask)\n+    return components\n+\n+\n+import numpy as np\n+import random\n+from scipy.ndimage import rotate, zoom\n+import re\n+from scipy.ndimage import rotate, zoom, binary_dilation, binary_erosion\n+from memory_profiler import profile\n+from skimage.morphology import disk\n+\n+def extract_foreground_mask(gt_image):\n+\n+    gray = cv2.cvtColor(gt_image, cv2.COLOR_RGB2GRAY)\n+\n+    _, binary_mask = cv2.threshold(gray, 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n+\n+    return binary_mask.astype(np.uint8)\n+\n+\n+\n+def get_next_image_index(directory, prefix=\"\"):\n+    existing_files = [f for f in os.listdir(directory) if f.startswith(prefix) and f.endswith(\".png\")]\n+    if not existing_files:\n+        return 0\n+    max_index = -1\n+    for f in existing_files:\n+        # '0001_sourcepath.png' -> '0001' -> 1\n+        match = re.match(r\"(\\d+)_\", f)\n+        if match:\n+            idx = int(match.group(1))\n+            if idx > max_index:\n+                max_index = idx\n+    return max_index + 1\n+\n+def reference_mask_augmentation(mask):\n+    mask = (mask > 0).astype(np.uint8)\n+    kernel_size = np.random.randint(5, 7)\n+    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))\n+    dilated_mask = cv2.dilate(mask, kernel, iterations=2)\n+    return dilated_mask\n+\n+def rotate_image_and_mask(image, mask):\n+    k = random.randint(0, 3) \n+    rotated_image = np.rot90(image, 2)\n+    rotated_mask = np.rot90(mask, 2)\n+    return rotated_image, rotated_mask\n+def rotate_image_and_mask2(image, mask):\n+    angle = random.uniform(0, 360)\n+    h, w = image.shape[:2]\n+    center = (w // 2, h // 2)\n+    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n+    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n+    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n+\n+    return rotated_image, rotated_mask\n+\n+def rotate_image_and_mask_for_transistor(image, ref_mask, tar_mask):\n+    '''Shift Defect'''\n+    angle = random.uniform(0, 360)\n+    h, w = image.shape[:2]\n+    center = (w // 2, h // 2)\n+    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n+    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT)\n+    rotated_ref_mask = cv2.warpAffine(ref_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n+    rotated_tar_mask = cv2.warpAffine(tar_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n+    return rotated_image, rotated_ref_mask, rotated_tar_mask\n+def rotate_mask(mask):\n+    \"\"\"\n+    Randomly rotate the mask around the center of the image\n+    \"\"\"\n+    height, width = mask.shape\n+    center = (width // 2, height // 2)\n+    angle = random.uniform(0, 360)\n+    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n+    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (width, height), \n+                                    flags=cv2.INTER_NEAREST,  \n+                                    borderMode=cv2.BORDER_CONSTANT, \n+                                    borderValue=0)  \n+    return rotated_mask\n+\n+\n+def seg_mask_augmentation(mask, reference_mask):\n+    original_size = mask.shape\n+    white_pixels = np.where(mask == 1)\n+    if len(white_pixels[0]) == 0:\n+        return mask\n+\n+    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n+    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n+    mid_x = (min_x + max_x) // 2\n+    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n+    angle = random.uniform(0, 360)\n+    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n+\n+    scale = random.uniform(0.7, 0.8)\n+    scaled = zoom(white_region, scale, order=0)\n+    \n+    reference_mask = (reference_mask > 0).astype(np.uint8)\n+\n+    new_mask = np.zeros(original_size, dtype=np.uint8)\n+\n+    ref_white_pixels = np.column_stack(np.where(reference_mask == 1))\n+    if len(ref_white_pixels) == 0:\n+        return mask  \n+\n+    center_y, center_x = random.choice(ref_white_pixels)\n+\n+    start_y = max(center_y - scaled.shape[0] // 2, 0)\n+    start_x = max(center_x - scaled.shape[1] // 2, 0)\n+\n+    end_y = min(start_y + scaled.shape[0], new_mask.shape[0])\n+    end_x = min(start_x + scaled.shape[1], new_mask.shape[1])\n+    scaled_cropped = scaled[:end_y-start_y, :end_x-start_x]\n+\n+    new_mask[start_y:end_y, start_x:end_x] = scaled_cropped\n+    return new_mask\n+\n+def seg_mask_random_placement_region(mask, object_mask):\n+    white_pixels = np.where(mask == 1)\n+    if len(white_pixels[0]) == 0:\n+        return mask\n+    \n+    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n+    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n+    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n+\n+    angle = random.uniform(0, 360)\n+    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n+    scale = random.uniform(0.9, 1.2)\n+    scaled = zoom(rotated, scale, order=0)\n+\n+    object_coords = np.argwhere(object_mask)\n+    if len(object_coords) == 0:\n+        return mask\n+    \n+    target_point = object_coords[np.random.choice(len(object_coords))]\n+\n+    new_mask = np.zeros_like(mask)\n+    h, w = scaled.shape\n+    top_left_y = target_point[0] - h // 2\n+    top_left_x = target_point[1] - w // 2\n+\n+    for i in range(h):\n+        for j in range(w):\n+            y, x = top_left_y + i, top_left_x + j\n+            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n+                if object_mask[y, x] == 1: \n+                    new_mask[y, x] = 1\n+    return new_mask\n+\n+def mask_augmentation(mask,diversity=True):\n+    original_size = mask.shape\n+    white_pixels = np.where(mask == 1)\n+    if len(white_pixels[0]) == 0:  \n+        return mask\n+    \n+    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n+    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n+    \n+    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n+    \n+    if diversity:\n+        angle = random.uniform(0, 360)\n+        rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n+        \n+        scale = random.uniform(0.7, 1.1)\n+        scaled = zoom(rotated, scale, order=0)\n+    else:\n+        scaled = white_region\n+\n+    new_mask = np.zeros(original_size, dtype=np.uint8)\n+    \n+    max_y_pos = original_size[0] - scaled.shape[0]\n+    max_x_pos = original_size[1] - scaled.shape[1]\n+\n+    if max_y_pos > 0 and max_x_pos > 0:\n+        y_pos = random.randint(0, max_y_pos)\n+        x_pos = random.randint(0, max_x_pos)\n+    else:\n+        scale_y = original_size[0] / scaled.shape[0]\n+        scale_x = original_size[1] / scaled.shape[1]\n+        scale = min(scale_y, scale_x) * 1 \n+        scaled = zoom(scaled, scale, order=0)\n+        y_pos = random.randint(0, original_size[0] - scaled.shape[0])\n+        x_pos = random.randint(0, original_size[1] - scaled.shape[1])\n+\n+    new_mask[y_pos:y_pos+scaled.shape[0], x_pos:x_pos+scaled.shape[1]] = scaled\n+    \n+    return new_mask\n+\n+def edge_mask_augmentation(mask, object_mask):\n+    white_pixels = np.where(mask == 1)\n+    if len(white_pixels[0]) == 0:\n+        return mask\n+    \n+    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n+    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n+    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n+\n+    angle = random.uniform(0, 360)\n+    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n+    scale = random.uniform(0.6, 0.9)\n+    scaled = zoom(rotated, scale, order=0)\n+\n+    kernel = disk(5)\n+    object_edge = binary_dilation(object_mask, structure=kernel) ^ binary_erosion(object_mask, structure=kernel)\n+\n+    edge_coords = np.argwhere(object_edge)\n+    if len(edge_coords) == 0:\n+        return mask\n+    target_point = edge_coords[np.random.choice(len(edge_coords))]\n+\n+    new_mask = np.zeros_like(mask)\n+    h, w = scaled.shape\n+    top_left_y = target_point[0] - h // 2\n+    top_left_x = target_point[1] - w // 2\n+\n+    for i in range(h):\n+        for j in range(w):\n+            y, x = top_left_y + i, top_left_x + j\n+            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n+                if object_mask[y, x] == 1: \n+                    new_mask[y, x] = 1\n+\n+    return new_mask\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754658594195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,11 +453,10 @@\n import random\n from scipy.ndimage import rotate, zoom\n import re\n from scipy.ndimage import rotate, zoom, binary_dilation, binary_erosion\n-from memory_profiler import profile\n from skimage.morphology import disk\n-\n+import os\n def extract_foreground_mask(gt_image):\n \n     gray = cv2.cvtColor(gt_image, cv2.COLOR_RGB2GRAY)\n \n@@ -670,676 +669,5 @@\n             if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n                 if object_mask[y, x] == 1: \n                     new_mask[y, x] = 1\n \n-    return new_mask\n-import numpy as np\n-import torch \n-import cv2\n-\n-def generate_mask_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n-    # 确保 ref_mask_compose 是二维的\n-    if len(ref_mask_compose.shape) == 3:\n-        ref_mask_compose = ref_mask_compose[:,:,0]\n-    \n-    # 将 ref_mask_compose 转换为布尔掩码\n-    ref_mask_bool = ref_mask_compose > 128\n-\n-    # 创建一个与 cropped_target_image 相同大小的空白图像\n-    ref_image_collage = cropped_target_image.copy()\n-\n-    # 获取目标区域的尺寸\n-    y1, y2, x1, x2 = tar_box_yyxx\n-    \n-    \n-    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n-    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n-    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n-    resized_ref_image = np.zeros((resized_ref_image.shape[0], resized_ref_image.shape[1], 3), dtype=np.uint8)\n-\n-    # 将调整大小后的参考图像的前景部分复制到目标区域\n-    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n-\n-    return ref_image_collage\n-\n-def generate_ref_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n-    # 确保 ref_mask_compose 是二维的\n-    if len(ref_mask_compose.shape) == 3:\n-        ref_mask_compose = ref_mask_compose[:,:,0]\n-    \n-    # 将 ref_mask_compose 转换为布尔掩码\n-    ref_mask_bool = ref_mask_compose > 128\n-\n-    # 创建一个与 cropped_target_image 相同大小的空白图像\n-    ref_image_collage = cropped_target_image.copy()\n-\n-    # 获取目标区域的尺寸\n-    y1, y2, x1, x2 = tar_box_yyxx\n-    \n-    \n-    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n-    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n-    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n-\n-    # 将调整大小后的参考图像的前景部分复制到目标区域\n-    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n-\n-    return ref_image_collage\n-\n-def mask_score(mask):\n-    '''Scoring the mask according to connectivity.'''\n-    mask = mask.astype(np.uint8)\n-    if mask.sum() < 10:\n-        return 0\n-    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n-    cnt_area = [cv2.contourArea(cnt) for cnt in contours]\n-    conc_score = np.max(cnt_area) / sum(cnt_area)\n-    return conc_score\n-\n-\n-def sobel(img, mask, thresh = 1):\n-    '''Calculating the high-frequency map.'''\n-    H,W = img.shape[0], img.shape[1]\n-    img = cv2.resize(img,(256,256))\n-    mask = (cv2.resize(mask,(256,256)) > 0.5).astype(np.uint8)\n-    kernel = np.ones((5,5),np.uint8)\n-    mask = cv2.erode(mask, kernel, iterations = 2)\n-    \n-    Ksize = 3\n-    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n-    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n-    sobel_X = cv2.convertScaleAbs(sobelx)\n-    sobel_Y = cv2.convertScaleAbs(sobely)\n-    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n-    scharr = np.max(scharr,-1) * mask    \n-    \n-    scharr[scharr < thresh] = 0.0\n-    scharr = np.stack([scharr,scharr,scharr],-1)\n-    scharr = (scharr.astype(np.float32)/255 * img.astype(np.float32) ).astype(np.uint8)\n-    scharr = cv2.resize(scharr,(W,H))\n-    return scharr\n-\n-\n-def resize_and_pad(image, box):\n-    '''Fitting an image to the box region while keeping the aspect ratio.'''\n-    y1,y2,x1,x2 = box\n-    H,W = y2-y1, x2-x1\n-    h,w =  image.shape[0], image.shape[1]\n-    r_box = W / H \n-    r_image = w / h\n-    if r_box >= r_image:\n-        h_target = H\n-        w_target = int(w * H / h) \n-        image = cv2.resize(image, (w_target, h_target))\n-\n-        w1 = (W - w_target) // 2\n-        w2 = W - w_target - w1\n-        pad_param = ((0,0),(w1,w2),(0,0))\n-        image = np.pad(image, pad_param, 'constant', constant_values=255)\n-    else:\n-        w_target = W \n-        h_target = int(h * W / w)\n-        image = cv2.resize(image, (w_target, h_target))\n-\n-        h1 = (H-h_target) // 2 \n-        h2 = H - h_target - h1\n-        pad_param =((h1,h2),(0,0),(0,0))\n-        image = np.pad(image, pad_param, 'constant', constant_values=255)\n-    return image\n-\n-\n-\n-def expand_image_mask(image, mask, ratio=1.4):\n-    h,w = image.shape[0], image.shape[1]\n-    H,W = int(h * ratio), int(w * ratio) \n-    h1 = int((H - h) // 2)\n-    h2 = H - h - h1\n-    w1 = int((W -w) // 2)\n-    w2 = W -w - w1\n-\n-    pad_param_image = ((h1,h2),(w1,w2),(0,0))\n-    pad_param_mask = ((h1,h2),(w1,w2))\n-    image = np.pad(image, pad_param_image, 'constant', constant_values=255)\n-    mask = np.pad(mask, pad_param_mask, 'constant', constant_values=0)\n-    return image, mask\n-\n-\n-def resize_box(yyxx, H,W,h,w):\n-    y1,y2,x1,x2 = yyxx\n-    y1,y2 = int(y1/H * h), int(y2/H * h)\n-    x1,x2 = int(x1/W * w), int(x2/W * w)\n-    y1,y2 = min(y1,h), min(y2,h)\n-    x1,x2 = min(x1,w), min(x2,w)\n-    return (y1,y2,x1,x2)\n-\n-\n-def get_bbox_from_mask(mask):\n-    h,w = mask.shape[0],mask.shape[1]\n-    if mask.sum() < 10:\n-        print(f\"mask is small,h:{h},w:{w}\")\n-        return 0,h,0,w\n-    rows = np.any(mask,axis=1)\n-    cols = np.any(mask,axis=0)\n-    y1,y2 = np.where(rows)[0][[0,-1]]\n-    x1,x2 = np.where(cols)[0][[0,-1]]\n-    return (y1,y2,x1,x2)\n-\n-\n-def expand_bbox(mask,yyxx,ratio=[1.2,2.0], min_crop=0):\n-    y1,y2,x1,x2 = yyxx\n-    ratio = np.random.randint( ratio[0] * 10,  ratio[1] * 10 ) / 10\n-    H,W = mask.shape[0], mask.shape[1]\n-    xc, yc = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n-    h = ratio * (y2-y1+1)\n-    w = ratio * (x2-x1+1)\n-    h = max(h,min_crop)\n-    w = max(w,min_crop)\n-\n-    x1 = int(xc - w * 0.5)\n-    x2 = int(xc + w * 0.5)\n-    y1 = int(yc - h * 0.5)\n-    y2 = int(yc + h * 0.5)\n-\n-    x1 = max(0,x1)\n-    x2 = min(W,x2)\n-    y1 = max(0,y1)\n-    y2 = min(H,y2)\n-    return (y1,y2,x1,x2)\n-\n-\n-def box2squre(image, box):\n-    H,W = image.shape[0], image.shape[1]\n-    y1,y2,x1,x2 = box\n-    cx = (x1 + x2) // 2\n-    cy = (y1 + y2) // 2\n-    h,w = y2-y1, x2-x1\n-\n-    if h >= w:\n-        x1 = cx - h//2\n-        x2 = cx + h//2\n-    else:\n-        y1 = cy - w//2\n-        y2 = cy + w//2\n-    x1 = max(0,x1)\n-    x2 = min(W,x2)\n-    y1 = max(0,y1)\n-    y2 = min(H,y2)\n-    return (y1,y2,x1,x2)\n-\n-\n-def pad_to_square(image, pad_value = 255, random = False):\n-    H,W = image.shape[0], image.shape[1]\n-    if H == W:\n-        return image\n-\n-    padd = abs(H - W)\n-    if random:\n-        padd_1 = int(np.random.randint(0,padd))\n-    else:\n-        padd_1 = int(padd / 2)\n-    padd_2 = padd - padd_1\n-\n-    if H > W:\n-        pad_param = ((0,0),(padd_1,padd_2),(0,0))\n-    else:\n-        pad_param = ((padd_1,padd_2),(0,0),(0,0))\n-\n-    image = np.pad(image, pad_param, 'constant', constant_values=pad_value)\n-    return image\n-\n-\n-\n-def box_in_box(small_box, big_box):\n-    y1,y2,x1,x2 = small_box\n-    y1_b, _, x1_b, _ = big_box\n-    y1,y2,x1,x2 = y1 - y1_b ,y2 - y1_b, x1 - x1_b ,x2 - x1_b\n-    return (y1,y2,x1,x2 )\n-\n-\n-\n-def shuffle_image(image, N):\n-    height, width = image.shape[:2]\n-    \n-    block_height = height // N\n-    block_width = width // N\n-    blocks = []\n-    \n-    for i in range(N):\n-        for j in range(N):\n-            block = image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width]\n-            blocks.append(block)\n-    \n-    np.random.shuffle(blocks)\n-    shuffled_image = np.zeros((height, width, 3), dtype=np.uint8)\n-\n-    for i in range(N):\n-        for j in range(N):\n-            shuffled_image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = blocks[i*N+j]\n-    return shuffled_image\n-\n-\n-def get_mosaic_mask(image, fg_mask, N=16, ratio = 0.5):\n-    ids = [i for i in range(N * N)]\n-    masked_number = int(N * N * ratio)\n-    masked_id = np.random.choice(ids, masked_number, replace=False)\n-    \n-\n-    \n-    height, width = image.shape[:2]\n-    mask = np.ones((height, width))\n-    \n-    block_height = height // N\n-    block_width = width // N\n-    \n-    b_id = 0\n-    for i in range(N):\n-        for j in range(N):\n-            if b_id in masked_id:\n-                mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] * 0\n-            b_id += 1\n-    mask = mask * fg_mask\n-    mask3 = np.stack([mask,mask,mask],-1).copy().astype(np.uint8)\n-    noise = q_x(image)\n-    noise_mask = image * mask3 + noise * (1-mask3)\n-    return noise_mask\n-\n-def extract_canney_noise(image, mask, dilate=True):\n-    h,w = image.shape[0],image.shape[1]\n-    mask = cv2.resize(mask.astype(np.uint8),(w,h)) > 0.5\n-    kernel = np.ones((8, 8), dtype=np.uint8)\n-    mask =  cv2.erode(mask.astype(np.uint8), kernel, 10)\n-\n-    canny = cv2.Canny(image, 50,100) * mask\n-    kernel = np.ones((8, 8), dtype=np.uint8)\n-    mask = (cv2.dilate(canny, kernel, 5) > 128).astype(np.uint8)\n-    mask = np.stack([mask,mask,mask],-1)\n-\n-    pure_noise = q_x(image, t=1) * 0 + 255\n-    canny_noise = mask * image + (1-mask) * pure_noise\n-    return canny_noise\n-\n-\n-def get_random_structure(size):\n-    choice = np.random.randint(1, 5)\n-\n-    if choice == 1:\n-        return cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))\n-    elif choice == 2:\n-        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size))\n-    elif choice == 3:\n-        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size//2))\n-    elif choice == 4:\n-        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size//2, size))\n-\n-def random_dilate(seg, min=3, max=10):\n-    size = np.random.randint(min, max)\n-    kernel = get_random_structure(size)\n-    seg = cv2.dilate(seg,kernel,iterations = 1)\n-    return seg\n-\n-def random_erode(seg, min=3, max=10):\n-    size = np.random.randint(min, max)\n-    kernel = get_random_structure(size)\n-    seg = cv2.erode(seg,kernel,iterations = 1)\n-    return seg\n-\n-def compute_iou(seg, gt):\n-    intersection = seg*gt\n-    union = seg+gt\n-    return (np.count_nonzero(intersection) + 1e-6) / (np.count_nonzero(union) + 1e-6)\n-\n-\n-def select_max_region(mask):\n-    nums, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n-    background = 0\n-    for row in range(stats.shape[0]):\n-        if stats[row, :][0] == 0 and stats[row, :][1] == 0:\n-            background = row\n-    stats_no_bg = np.delete(stats, background, axis=0)\n-    max_idx = stats_no_bg[:, 4].argmax()\n-    max_region = np.where(labels==max_idx+1, 1, 0)\n-\n-    return max_region.astype(np.uint8)\n-\n-\n-\n-def perturb_mask(gt, min_iou = 0.3,  max_iou = 0.99):\n-    iou_target = np.random.uniform(min_iou, max_iou)\n-    h, w = gt.shape\n-    gt = gt.astype(np.uint8)\n-    seg = gt.copy()\n-    \n-    # Rare case\n-    if h <= 2 or w <= 2:\n-        print('GT too small, returning original')\n-        return seg\n-\n-    # Do a bunch of random operations\n-    for _ in range(250):\n-        for _ in range(4):\n-            lx, ly = np.random.randint(w), np.random.randint(h)\n-            lw, lh = np.random.randint(lx+1,w+1), np.random.randint(ly+1,h+1)\n-\n-            # Randomly set one pixel to 1/0. With the following dilate/erode, we can create holes/external regions\n-            if np.random.rand() < 0.1:\n-                cx = int((lx + lw) / 2)\n-                cy = int((ly + lh) / 2)\n-                seg[cy, cx] = np.random.randint(2) * 255\n-\n-            # Dilate/erode\n-            if np.random.rand() < 0.5:\n-                seg[ly:lh, lx:lw] = random_dilate(seg[ly:lh, lx:lw])\n-            else:\n-                seg[ly:lh, lx:lw] = random_erode(seg[ly:lh, lx:lw])\n-            \n-            seg = np.logical_or(seg, gt).astype(np.uint8)\n-            #seg = select_max_region(seg) \n-\n-        if compute_iou(seg, gt) < iou_target:\n-            break\n-    seg = select_max_region(seg.astype(np.uint8)) \n-    return seg.astype(np.uint8)\n-\n-\n-def q_x(x_0,t=65):\n-    '''Adding noise for and given image.'''\n-    x_0 = torch.from_numpy(x_0).float() / 127.5 - 1\n-    num_steps = 100\n-    \n-    betas = torch.linspace(-6,6,num_steps)\n-    betas = torch.sigmoid(betas)*(0.5e-2 - 1e-5)+1e-5\n-\n-    alphas = 1-betas\n-    alphas_prod = torch.cumprod(alphas,0)\n-    \n-    alphas_prod_p = torch.cat([torch.tensor([1]).float(),alphas_prod[:-1]],0)\n-    alphas_bar_sqrt = torch.sqrt(alphas_prod)\n-    one_minus_alphas_bar_log = torch.log(1 - alphas_prod)\n-    one_minus_alphas_bar_sqrt = torch.sqrt(1 - alphas_prod)\n-    \n-    noise = torch.randn_like(x_0)\n-    alphas_t = alphas_bar_sqrt[t]\n-    alphas_1_m_t = one_minus_alphas_bar_sqrt[t]\n-    return (alphas_t * x_0 + alphas_1_m_t * noise).numpy()  * 127.5 + 127.5 \n-\n-\n-def extract_target_boundary(img, target_mask):\n-    Ksize = 3\n-    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n-    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n-\n-    # sobel-x\n-    sobel_X = cv2.convertScaleAbs(sobelx)\n-    # sobel-y\n-    sobel_Y = cv2.convertScaleAbs(sobely)\n-    # sobel-xy\n-    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n-    scharr = np.max(scharr,-1).astype(np.float32)/255\n-    scharr = scharr *  target_mask.astype(np.float32)\n-    return scharr\n-\n-\n-#===============================================================================\n-\n-def preprocess_image(img, target_shape):\n-    h, w = target_shape\n-\n-    # Resize to target shape\n-    if img.shape[:2] != (h, w):\n-        img = cv2.resize(img, (w, h))\n-\n-    # If shape is (h, w) or (h, w, 1), convert to 3 channels\n-    if len(img.shape) == 2:\n-        img = np.stack([img] * 3, axis=-1)\n-    elif img.shape[2] == 1:\n-        img = np.concatenate([img] * 3, axis=-1)\n-\n-    # Scale if float (like ref_processed which might be [0, 1])\n-    if img.dtype != np.uint8:\n-        img = (img * 255).clip(0, 255).astype(np.uint8)\n-\n-    return img\n-def compose_images(ref_image, ref_mask, gt_image, tar_mask, synthesis, ref_processed):\n-    h, w = ref_image.shape[:2]\n-    grid = np.zeros((h*2, w*3, 3), dtype=np.uint8)\n-    if ref_processed.shape[:2] != (h, w):\n-        ref_processed = cv2.resize(ref_processed, (w, h))\n-    \n-    images = [ref_image, ref_mask[:,:,None]*255, gt_image,\n-              tar_mask[:,:,None]*255, ref_processed*255, synthesis]\n-    positions = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2)]\n-    \n-    for img, (i, j) in zip(images, positions):\n-        grid[i*h:(i+1)*h, j*w:(j+1)*w] = img\n-    \n-    return grid\n-\n-\n-def get_connected_components(mask):\n-    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n-    components = []\n-    for i in range(1, num_labels):  \n-        component_mask = (labels == i).astype(np.uint8)\n-        components.append(component_mask)\n-    return components\n-\n-\n-import numpy as np\n-import random\n-from scipy.ndimage import rotate, zoom\n-import re\n-\n-def extract_foreground_mask(gt_image):\n-\n-    gray = cv2.cvtColor(gt_image, cv2.COLOR_RGB2GRAY)\n-\n-    _, binary_mask = cv2.threshold(gray, 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n-\n-    return binary_mask.astype(np.uint8)\n-\n-\n-\n-def get_next_image_index(directory, prefix=\"\"):\n-    existing_files = [f for f in os.listdir(directory) if f.startswith(prefix) and f.endswith(\".png\")]\n-    if not existing_files:\n-        return 0\n-    max_index = -1\n-    for f in existing_files:\n-        # '0001_sourcepath.png' -> '0001' -> 1\n-        match = re.match(r\"(\\d+)_\", f)\n-        if match:\n-            idx = int(match.group(1))\n-            if idx > max_index:\n-                max_index = idx\n-    return max_index + 1\n-\n-def reference_mask_augmentation(mask):\n-    mask = (mask > 0).astype(np.uint8)\n-    kernel_size = np.random.randint(5, 7)\n-    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))\n-    dilated_mask = cv2.dilate(mask, kernel, iterations=2)\n-    return dilated_mask\n-\n-def rotate_image_and_mask(image, mask):\n-    k = random.randint(0, 3) \n-    rotated_image = np.rot90(image, 2)\n-    rotated_mask = np.rot90(mask, 2)\n-    return rotated_image, rotated_mask\n-def rotate_image_and_mask2(image, mask):\n-    angle = random.uniform(0, 360)\n-    h, w = image.shape[:2]\n-    center = (w // 2, h // 2)\n-    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n-    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n-    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n-\n-    return rotated_image, rotated_mask\n-\n-def rotate_image_and_mask_for_transistor(image, ref_mask, tar_mask):\n-    '''Shift Defect'''\n-    angle = random.uniform(0, 360)\n-    h, w = image.shape[:2]\n-    center = (w // 2, h // 2)\n-    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n-    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT)\n-    rotated_ref_mask = cv2.warpAffine(ref_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n-    rotated_tar_mask = cv2.warpAffine(tar_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n-    return rotated_image, rotated_ref_mask, rotated_tar_mask\n-def rotate_mask(mask):\n-    \"\"\"\n-    Randomly rotate the mask around the center of the image\n-    \"\"\"\n-    height, width = mask.shape\n-    center = (width // 2, height // 2)\n-    angle = random.uniform(0, 360)\n-    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n-    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (width, height), \n-                                    flags=cv2.INTER_NEAREST,  \n-                                    borderMode=cv2.BORDER_CONSTANT, \n-                                    borderValue=0)  \n-    return rotated_mask\n-\n-\n-def seg_mask_augmentation(mask, reference_mask):\n-    original_size = mask.shape\n-    white_pixels = np.where(mask == 1)\n-    if len(white_pixels[0]) == 0:\n-        return mask\n-\n-    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n-    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n-    mid_x = (min_x + max_x) // 2\n-    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n-    angle = random.uniform(0, 360)\n-    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n-\n-    scale = random.uniform(0.7, 0.8)\n-    scaled = zoom(white_region, scale, order=0)\n-    \n-    reference_mask = (reference_mask > 0).astype(np.uint8)\n-\n-    new_mask = np.zeros(original_size, dtype=np.uint8)\n-\n-    ref_white_pixels = np.column_stack(np.where(reference_mask == 1))\n-    if len(ref_white_pixels) == 0:\n-        return mask  \n-\n-    center_y, center_x = random.choice(ref_white_pixels)\n-\n-    start_y = max(center_y - scaled.shape[0] // 2, 0)\n-    start_x = max(center_x - scaled.shape[1] // 2, 0)\n-\n-    end_y = min(start_y + scaled.shape[0], new_mask.shape[0])\n-    end_x = min(start_x + scaled.shape[1], new_mask.shape[1])\n-    scaled_cropped = scaled[:end_y-start_y, :end_x-start_x]\n-\n-    new_mask[start_y:end_y, start_x:end_x] = scaled_cropped\n-    return new_mask\n-\n-def seg_mask_random_placement_region(mask, object_mask):\n-    white_pixels = np.where(mask == 1)\n-    if len(white_pixels[0]) == 0:\n-        return mask\n-    \n-    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n-    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n-    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n-\n-    angle = random.uniform(0, 360)\n-    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n-    scale = random.uniform(0.9, 1.2)\n-    scaled = zoom(rotated, scale, order=0)\n-\n-    object_coords = np.argwhere(object_mask)\n-    if len(object_coords) == 0:\n-        return mask\n-    \n-    target_point = object_coords[np.random.choice(len(object_coords))]\n-\n-    new_mask = np.zeros_like(mask)\n-    h, w = scaled.shape\n-    top_left_y = target_point[0] - h // 2\n-    top_left_x = target_point[1] - w // 2\n-\n-    for i in range(h):\n-        for j in range(w):\n-            y, x = top_left_y + i, top_left_x + j\n-            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n-                if object_mask[y, x] == 1: \n-                    new_mask[y, x] = 1\n-    return new_mask\n-\n-def mask_augmentation(mask,diversity=True):\n-    original_size = mask.shape\n-    white_pixels = np.where(mask == 1)\n-    if len(white_pixels[0]) == 0:  \n-        return mask\n-    \n-    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n-    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n-    \n-    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n-    \n-    if diversity:\n-        angle = random.uniform(0, 360)\n-        rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n-        \n-        scale = random.uniform(0.7, 1.1)\n-        scaled = zoom(rotated, scale, order=0)\n-    else:\n-        scaled = white_region\n-\n-    new_mask = np.zeros(original_size, dtype=np.uint8)\n-    \n-    max_y_pos = original_size[0] - scaled.shape[0]\n-    max_x_pos = original_size[1] - scaled.shape[1]\n-\n-    if max_y_pos > 0 and max_x_pos > 0:\n-        y_pos = random.randint(0, max_y_pos)\n-        x_pos = random.randint(0, max_x_pos)\n-    else:\n-        scale_y = original_size[0] / scaled.shape[0]\n-        scale_x = original_size[1] / scaled.shape[1]\n-        scale = min(scale_y, scale_x) * 1 \n-        scaled = zoom(scaled, scale, order=0)\n-        y_pos = random.randint(0, original_size[0] - scaled.shape[0])\n-        x_pos = random.randint(0, original_size[1] - scaled.shape[1])\n-\n-    new_mask[y_pos:y_pos+scaled.shape[0], x_pos:x_pos+scaled.shape[1]] = scaled\n-    \n-    return new_mask\n-\n-def edge_mask_augmentation(mask, object_mask):\n-    white_pixels = np.where(mask == 1)\n-    if len(white_pixels[0]) == 0:\n-        return mask\n-    \n-    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n-    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n-    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n-\n-    angle = random.uniform(0, 360)\n-    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n-    scale = random.uniform(0.6, 0.9)\n-    scaled = zoom(rotated, scale, order=0)\n-\n-    kernel = disk(5)\n-    object_edge = binary_dilation(object_mask, structure=kernel) ^ binary_erosion(object_mask, structure=kernel)\n-\n-    edge_coords = np.argwhere(object_edge)\n-    if len(edge_coords) == 0:\n-        return mask\n-    target_point = edge_coords[np.random.choice(len(edge_coords))]\n-\n-    new_mask = np.zeros_like(mask)\n-    h, w = scaled.shape\n-    top_left_y = target_point[0] - h // 2\n-    top_left_x = target_point[1] - w // 2\n-\n-    for i in range(h):\n-        for j in range(w):\n-            y, x = top_left_y + i, top_left_x + j\n-            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n-                if object_mask[y, x] == 1: \n-                    new_mask[y, x] = 1\n-\n     return new_mask\n\\ No newline at end of file\n"
                }
            ],
            "date": 1754658546396,
            "name": "Commit-0",
            "content": "import numpy as np\nimport torch \nimport cv2\n\ndef generate_mask_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n    # 确保 ref_mask_compose 是二维的\n    if len(ref_mask_compose.shape) == 3:\n        ref_mask_compose = ref_mask_compose[:,:,0]\n    \n    # 将 ref_mask_compose 转换为布尔掩码\n    ref_mask_bool = ref_mask_compose > 128\n\n    # 创建一个与 cropped_target_image 相同大小的空白图像\n    ref_image_collage = cropped_target_image.copy()\n\n    # 获取目标区域的尺寸\n    y1, y2, x1, x2 = tar_box_yyxx\n    \n    \n    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n    resized_ref_image = np.zeros((resized_ref_image.shape[0], resized_ref_image.shape[1], 3), dtype=np.uint8)\n\n    # 将调整大小后的参考图像的前景部分复制到目标区域\n    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n\n    return ref_image_collage\n\ndef generate_ref_image_collage(masked_ref_image_compose, ref_mask_compose, cropped_target_image, tar_box_yyxx):\n    # 确保 ref_mask_compose 是二维的\n    if len(ref_mask_compose.shape) == 3:\n        ref_mask_compose = ref_mask_compose[:,:,0]\n    \n    # 将 ref_mask_compose 转换为布尔掩码\n    ref_mask_bool = ref_mask_compose > 128\n\n    # 创建一个与 cropped_target_image 相同大小的空白图像\n    ref_image_collage = cropped_target_image.copy()\n\n    # 获取目标区域的尺寸\n    y1, y2, x1, x2 = tar_box_yyxx\n    \n    \n    # 调整 masked_ref_image_compose 和 ref_mask_bool 的大小以匹配目标区域\n    resized_ref_image = cv2.resize(masked_ref_image_compose, (x2-x1, y2-y1))\n    resized_ref_mask = cv2.resize(ref_mask_bool.astype(np.uint8), (x2-x1, y2-y1), interpolation=cv2.INTER_NEAREST)\n\n    # 将调整大小后的参考图像的前景部分复制到目标区域\n    ref_image_collage = np.where(np.expand_dims(resized_ref_mask, axis=2), resized_ref_image, cropped_target_image[y1:y2, x1:x2])\n\n    return ref_image_collage\n\ndef mask_score(mask):\n    '''Scoring the mask according to connectivity.'''\n    mask = mask.astype(np.uint8)\n    if mask.sum() < 10:\n        return 0\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n    cnt_area = [cv2.contourArea(cnt) for cnt in contours]\n    conc_score = np.max(cnt_area) / sum(cnt_area)\n    return conc_score\n\n\ndef sobel(img, mask, thresh = 1):\n    '''Calculating the high-frequency map.'''\n    H,W = img.shape[0], img.shape[1]\n    img = cv2.resize(img,(256,256))\n    mask = (cv2.resize(mask,(256,256)) > 0.5).astype(np.uint8)\n    kernel = np.ones((5,5),np.uint8)\n    mask = cv2.erode(mask, kernel, iterations = 2)\n    \n    Ksize = 3\n    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n    sobel_X = cv2.convertScaleAbs(sobelx)\n    sobel_Y = cv2.convertScaleAbs(sobely)\n    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n    scharr = np.max(scharr,-1) * mask    \n    \n    scharr[scharr < thresh] = 0.0\n    scharr = np.stack([scharr,scharr,scharr],-1)\n    scharr = (scharr.astype(np.float32)/255 * img.astype(np.float32) ).astype(np.uint8)\n    scharr = cv2.resize(scharr,(W,H))\n    return scharr\n\n\ndef resize_and_pad(image, box):\n    '''Fitting an image to the box region while keeping the aspect ratio.'''\n    y1,y2,x1,x2 = box\n    H,W = y2-y1, x2-x1\n    h,w =  image.shape[0], image.shape[1]\n    r_box = W / H \n    r_image = w / h\n    if r_box >= r_image:\n        h_target = H\n        w_target = int(w * H / h) \n        image = cv2.resize(image, (w_target, h_target))\n\n        w1 = (W - w_target) // 2\n        w2 = W - w_target - w1\n        pad_param = ((0,0),(w1,w2),(0,0))\n        image = np.pad(image, pad_param, 'constant', constant_values=255)\n    else:\n        w_target = W \n        h_target = int(h * W / w)\n        image = cv2.resize(image, (w_target, h_target))\n\n        h1 = (H-h_target) // 2 \n        h2 = H - h_target - h1\n        pad_param =((h1,h2),(0,0),(0,0))\n        image = np.pad(image, pad_param, 'constant', constant_values=255)\n    return image\n\n\n\ndef expand_image_mask(image, mask, ratio=1.4):\n    h,w = image.shape[0], image.shape[1]\n    H,W = int(h * ratio), int(w * ratio) \n    h1 = int((H - h) // 2)\n    h2 = H - h - h1\n    w1 = int((W -w) // 2)\n    w2 = W -w - w1\n\n    pad_param_image = ((h1,h2),(w1,w2),(0,0))\n    pad_param_mask = ((h1,h2),(w1,w2))\n    image = np.pad(image, pad_param_image, 'constant', constant_values=255)\n    mask = np.pad(mask, pad_param_mask, 'constant', constant_values=0)\n    return image, mask\n\n\ndef resize_box(yyxx, H,W,h,w):\n    y1,y2,x1,x2 = yyxx\n    y1,y2 = int(y1/H * h), int(y2/H * h)\n    x1,x2 = int(x1/W * w), int(x2/W * w)\n    y1,y2 = min(y1,h), min(y2,h)\n    x1,x2 = min(x1,w), min(x2,w)\n    return (y1,y2,x1,x2)\n\n\ndef get_bbox_from_mask(mask):\n    h,w = mask.shape[0],mask.shape[1]\n    if mask.sum() < 10:\n        print(f\"mask is small,h:{h},w:{w}\")\n        return 0,h,0,w\n    rows = np.any(mask,axis=1)\n    cols = np.any(mask,axis=0)\n    y1,y2 = np.where(rows)[0][[0,-1]]\n    x1,x2 = np.where(cols)[0][[0,-1]]\n    return (y1,y2,x1,x2)\n\n\ndef expand_bbox(mask,yyxx,ratio=[1.2,2.0], min_crop=0):\n    y1,y2,x1,x2 = yyxx\n    ratio = np.random.randint( ratio[0] * 10,  ratio[1] * 10 ) / 10\n    H,W = mask.shape[0], mask.shape[1]\n    xc, yc = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n    h = ratio * (y2-y1+1)\n    w = ratio * (x2-x1+1)\n    h = max(h,min_crop)\n    w = max(w,min_crop)\n\n    x1 = int(xc - w * 0.5)\n    x2 = int(xc + w * 0.5)\n    y1 = int(yc - h * 0.5)\n    y2 = int(yc + h * 0.5)\n\n    x1 = max(0,x1)\n    x2 = min(W,x2)\n    y1 = max(0,y1)\n    y2 = min(H,y2)\n    return (y1,y2,x1,x2)\n\n\ndef box2squre(image, box):\n    H,W = image.shape[0], image.shape[1]\n    y1,y2,x1,x2 = box\n    cx = (x1 + x2) // 2\n    cy = (y1 + y2) // 2\n    h,w = y2-y1, x2-x1\n\n    if h >= w:\n        x1 = cx - h//2\n        x2 = cx + h//2\n    else:\n        y1 = cy - w//2\n        y2 = cy + w//2\n    x1 = max(0,x1)\n    x2 = min(W,x2)\n    y1 = max(0,y1)\n    y2 = min(H,y2)\n    return (y1,y2,x1,x2)\n\n\ndef pad_to_square(image, pad_value = 255, random = False):\n    H,W = image.shape[0], image.shape[1]\n    if H == W:\n        return image\n\n    padd = abs(H - W)\n    if random:\n        padd_1 = int(np.random.randint(0,padd))\n    else:\n        padd_1 = int(padd / 2)\n    padd_2 = padd - padd_1\n\n    if H > W:\n        pad_param = ((0,0),(padd_1,padd_2),(0,0))\n    else:\n        pad_param = ((padd_1,padd_2),(0,0),(0,0))\n\n    image = np.pad(image, pad_param, 'constant', constant_values=pad_value)\n    return image\n\n\n\ndef box_in_box(small_box, big_box):\n    y1,y2,x1,x2 = small_box\n    y1_b, _, x1_b, _ = big_box\n    y1,y2,x1,x2 = y1 - y1_b ,y2 - y1_b, x1 - x1_b ,x2 - x1_b\n    return (y1,y2,x1,x2 )\n\n\n\ndef shuffle_image(image, N):\n    height, width = image.shape[:2]\n    \n    block_height = height // N\n    block_width = width // N\n    blocks = []\n    \n    for i in range(N):\n        for j in range(N):\n            block = image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width]\n            blocks.append(block)\n    \n    np.random.shuffle(blocks)\n    shuffled_image = np.zeros((height, width, 3), dtype=np.uint8)\n\n    for i in range(N):\n        for j in range(N):\n            shuffled_image[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = blocks[i*N+j]\n    return shuffled_image\n\n\ndef get_mosaic_mask(image, fg_mask, N=16, ratio = 0.5):\n    ids = [i for i in range(N * N)]\n    masked_number = int(N * N * ratio)\n    masked_id = np.random.choice(ids, masked_number, replace=False)\n    \n\n    \n    height, width = image.shape[:2]\n    mask = np.ones((height, width))\n    \n    block_height = height // N\n    block_width = width // N\n    \n    b_id = 0\n    for i in range(N):\n        for j in range(N):\n            if b_id in masked_id:\n                mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] = mask[i*block_height:(i+1)*block_height, j*block_width:(j+1)*block_width] * 0\n            b_id += 1\n    mask = mask * fg_mask\n    mask3 = np.stack([mask,mask,mask],-1).copy().astype(np.uint8)\n    noise = q_x(image)\n    noise_mask = image * mask3 + noise * (1-mask3)\n    return noise_mask\n\ndef extract_canney_noise(image, mask, dilate=True):\n    h,w = image.shape[0],image.shape[1]\n    mask = cv2.resize(mask.astype(np.uint8),(w,h)) > 0.5\n    kernel = np.ones((8, 8), dtype=np.uint8)\n    mask =  cv2.erode(mask.astype(np.uint8), kernel, 10)\n\n    canny = cv2.Canny(image, 50,100) * mask\n    kernel = np.ones((8, 8), dtype=np.uint8)\n    mask = (cv2.dilate(canny, kernel, 5) > 128).astype(np.uint8)\n    mask = np.stack([mask,mask,mask],-1)\n\n    pure_noise = q_x(image, t=1) * 0 + 255\n    canny_noise = mask * image + (1-mask) * pure_noise\n    return canny_noise\n\n\ndef get_random_structure(size):\n    choice = np.random.randint(1, 5)\n\n    if choice == 1:\n        return cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))\n    elif choice == 2:\n        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size))\n    elif choice == 3:\n        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size, size//2))\n    elif choice == 4:\n        return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (size//2, size))\n\ndef random_dilate(seg, min=3, max=10):\n    size = np.random.randint(min, max)\n    kernel = get_random_structure(size)\n    seg = cv2.dilate(seg,kernel,iterations = 1)\n    return seg\n\ndef random_erode(seg, min=3, max=10):\n    size = np.random.randint(min, max)\n    kernel = get_random_structure(size)\n    seg = cv2.erode(seg,kernel,iterations = 1)\n    return seg\n\ndef compute_iou(seg, gt):\n    intersection = seg*gt\n    union = seg+gt\n    return (np.count_nonzero(intersection) + 1e-6) / (np.count_nonzero(union) + 1e-6)\n\n\ndef select_max_region(mask):\n    nums, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n    background = 0\n    for row in range(stats.shape[0]):\n        if stats[row, :][0] == 0 and stats[row, :][1] == 0:\n            background = row\n    stats_no_bg = np.delete(stats, background, axis=0)\n    max_idx = stats_no_bg[:, 4].argmax()\n    max_region = np.where(labels==max_idx+1, 1, 0)\n\n    return max_region.astype(np.uint8)\n\n\n\ndef perturb_mask(gt, min_iou = 0.3,  max_iou = 0.99):\n    iou_target = np.random.uniform(min_iou, max_iou)\n    h, w = gt.shape\n    gt = gt.astype(np.uint8)\n    seg = gt.copy()\n    \n    # Rare case\n    if h <= 2 or w <= 2:\n        print('GT too small, returning original')\n        return seg\n\n    # Do a bunch of random operations\n    for _ in range(250):\n        for _ in range(4):\n            lx, ly = np.random.randint(w), np.random.randint(h)\n            lw, lh = np.random.randint(lx+1,w+1), np.random.randint(ly+1,h+1)\n\n            # Randomly set one pixel to 1/0. With the following dilate/erode, we can create holes/external regions\n            if np.random.rand() < 0.1:\n                cx = int((lx + lw) / 2)\n                cy = int((ly + lh) / 2)\n                seg[cy, cx] = np.random.randint(2) * 255\n\n            # Dilate/erode\n            if np.random.rand() < 0.5:\n                seg[ly:lh, lx:lw] = random_dilate(seg[ly:lh, lx:lw])\n            else:\n                seg[ly:lh, lx:lw] = random_erode(seg[ly:lh, lx:lw])\n            \n            seg = np.logical_or(seg, gt).astype(np.uint8)\n            #seg = select_max_region(seg) \n\n        if compute_iou(seg, gt) < iou_target:\n            break\n    seg = select_max_region(seg.astype(np.uint8)) \n    return seg.astype(np.uint8)\n\n\ndef q_x(x_0,t=65):\n    '''Adding noise for and given image.'''\n    x_0 = torch.from_numpy(x_0).float() / 127.5 - 1\n    num_steps = 100\n    \n    betas = torch.linspace(-6,6,num_steps)\n    betas = torch.sigmoid(betas)*(0.5e-2 - 1e-5)+1e-5\n\n    alphas = 1-betas\n    alphas_prod = torch.cumprod(alphas,0)\n    \n    alphas_prod_p = torch.cat([torch.tensor([1]).float(),alphas_prod[:-1]],0)\n    alphas_bar_sqrt = torch.sqrt(alphas_prod)\n    one_minus_alphas_bar_log = torch.log(1 - alphas_prod)\n    one_minus_alphas_bar_sqrt = torch.sqrt(1 - alphas_prod)\n    \n    noise = torch.randn_like(x_0)\n    alphas_t = alphas_bar_sqrt[t]\n    alphas_1_m_t = one_minus_alphas_bar_sqrt[t]\n    return (alphas_t * x_0 + alphas_1_m_t * noise).numpy()  * 127.5 + 127.5 \n\n\ndef extract_target_boundary(img, target_mask):\n    Ksize = 3\n    sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=Ksize)\n    sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=Ksize)\n\n    # sobel-x\n    sobel_X = cv2.convertScaleAbs(sobelx)\n    # sobel-y\n    sobel_Y = cv2.convertScaleAbs(sobely)\n    # sobel-xy\n    scharr = cv2.addWeighted(sobel_X, 0.5, sobel_Y, 0.5, 0)\n    scharr = np.max(scharr,-1).astype(np.float32)/255\n    scharr = scharr *  target_mask.astype(np.float32)\n    return scharr\n\n\n#===============================================================================\n\ndef preprocess_image(img, target_shape):\n    h, w = target_shape\n\n    # Resize to target shape\n    if img.shape[:2] != (h, w):\n        img = cv2.resize(img, (w, h))\n\n    # If shape is (h, w) or (h, w, 1), convert to 3 channels\n    if len(img.shape) == 2:\n        img = np.stack([img] * 3, axis=-1)\n    elif img.shape[2] == 1:\n        img = np.concatenate([img] * 3, axis=-1)\n\n    # Scale if float (like ref_processed which might be [0, 1])\n    if img.dtype != np.uint8:\n        img = (img * 255).clip(0, 255).astype(np.uint8)\n\n    return img\ndef compose_images(ref_image, ref_mask, gt_image, tar_mask, synthesis, ref_processed):\n    h, w = ref_image.shape[:2]\n    grid = np.zeros((h*2, w*3, 3), dtype=np.uint8)\n    if ref_processed.shape[:2] != (h, w):\n        ref_processed = cv2.resize(ref_processed, (w, h))\n    \n    images = [ref_image, ref_mask[:,:,None]*255, gt_image,\n              tar_mask[:,:,None]*255, ref_processed*255, synthesis]\n    positions = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2)]\n    \n    for img, (i, j) in zip(images, positions):\n        grid[i*h:(i+1)*h, j*w:(j+1)*w] = img\n    \n    return grid\n\n\ndef get_connected_components(mask):\n    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n    components = []\n    for i in range(1, num_labels):  \n        component_mask = (labels == i).astype(np.uint8)\n        components.append(component_mask)\n    return components\n\n\nimport numpy as np\nimport random\nfrom scipy.ndimage import rotate, zoom\nimport re\n\ndef extract_foreground_mask(gt_image):\n\n    gray = cv2.cvtColor(gt_image, cv2.COLOR_RGB2GRAY)\n\n    _, binary_mask = cv2.threshold(gray, 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n\n    return binary_mask.astype(np.uint8)\n\n\n\ndef get_next_image_index(directory, prefix=\"\"):\n    existing_files = [f for f in os.listdir(directory) if f.startswith(prefix) and f.endswith(\".png\")]\n    if not existing_files:\n        return 0\n    max_index = -1\n    for f in existing_files:\n        # '0001_sourcepath.png' -> '0001' -> 1\n        match = re.match(r\"(\\d+)_\", f)\n        if match:\n            idx = int(match.group(1))\n            if idx > max_index:\n                max_index = idx\n    return max_index + 1\n\ndef reference_mask_augmentation(mask):\n    mask = (mask > 0).astype(np.uint8)\n    kernel_size = np.random.randint(5, 7)\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))\n    dilated_mask = cv2.dilate(mask, kernel, iterations=2)\n    return dilated_mask\n\ndef rotate_image_and_mask(image, mask):\n    k = random.randint(0, 3) \n    rotated_image = np.rot90(image, 2)\n    rotated_mask = np.rot90(mask, 2)\n    return rotated_image, rotated_mask\ndef rotate_image_and_mask2(image, mask):\n    angle = random.uniform(0, 360)\n    h, w = image.shape[:2]\n    center = (w // 2, h // 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n\n    return rotated_image, rotated_mask\n\ndef rotate_image_and_mask_for_transistor(image, ref_mask, tar_mask):\n    '''Shift Defect'''\n    angle = random.uniform(0, 360)\n    h, w = image.shape[:2]\n    center = (w // 2, h // 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT)\n    rotated_ref_mask = cv2.warpAffine(ref_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n    rotated_tar_mask = cv2.warpAffine(tar_mask, rotation_matrix, (w, h), flags=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)\n    return rotated_image, rotated_ref_mask, rotated_tar_mask\ndef rotate_mask(mask):\n    \"\"\"\n    Randomly rotate the mask around the center of the image\n    \"\"\"\n    height, width = mask.shape\n    center = (width // 2, height // 2)\n    angle = random.uniform(0, 360)\n    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    rotated_mask = cv2.warpAffine(mask, rotation_matrix, (width, height), \n                                    flags=cv2.INTER_NEAREST,  \n                                    borderMode=cv2.BORDER_CONSTANT, \n                                    borderValue=0)  \n    return rotated_mask\n\n\ndef seg_mask_augmentation(mask, reference_mask):\n    original_size = mask.shape\n    white_pixels = np.where(mask == 1)\n    if len(white_pixels[0]) == 0:\n        return mask\n\n    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n    mid_x = (min_x + max_x) // 2\n    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n    angle = random.uniform(0, 360)\n    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n\n    scale = random.uniform(0.7, 0.8)\n    scaled = zoom(white_region, scale, order=0)\n    \n    reference_mask = (reference_mask > 0).astype(np.uint8)\n\n    new_mask = np.zeros(original_size, dtype=np.uint8)\n\n    ref_white_pixels = np.column_stack(np.where(reference_mask == 1))\n    if len(ref_white_pixels) == 0:\n        return mask  \n\n    center_y, center_x = random.choice(ref_white_pixels)\n\n    start_y = max(center_y - scaled.shape[0] // 2, 0)\n    start_x = max(center_x - scaled.shape[1] // 2, 0)\n\n    end_y = min(start_y + scaled.shape[0], new_mask.shape[0])\n    end_x = min(start_x + scaled.shape[1], new_mask.shape[1])\n    scaled_cropped = scaled[:end_y-start_y, :end_x-start_x]\n\n    new_mask[start_y:end_y, start_x:end_x] = scaled_cropped\n    return new_mask\n\ndef seg_mask_random_placement_region(mask, object_mask):\n    white_pixels = np.where(mask == 1)\n    if len(white_pixels[0]) == 0:\n        return mask\n    \n    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n\n    angle = random.uniform(0, 360)\n    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n    scale = random.uniform(0.9, 1.2)\n    scaled = zoom(rotated, scale, order=0)\n\n    object_coords = np.argwhere(object_mask)\n    if len(object_coords) == 0:\n        return mask\n    \n    target_point = object_coords[np.random.choice(len(object_coords))]\n\n    new_mask = np.zeros_like(mask)\n    h, w = scaled.shape\n    top_left_y = target_point[0] - h // 2\n    top_left_x = target_point[1] - w // 2\n\n    for i in range(h):\n        for j in range(w):\n            y, x = top_left_y + i, top_left_x + j\n            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n                if object_mask[y, x] == 1: \n                    new_mask[y, x] = 1\n    return new_mask\n\ndef mask_augmentation(mask,diversity=True):\n    original_size = mask.shape\n    white_pixels = np.where(mask == 1)\n    if len(white_pixels[0]) == 0:  \n        return mask\n    \n    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n    \n    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n    \n    if diversity:\n        angle = random.uniform(0, 360)\n        rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n        \n        scale = random.uniform(0.7, 1.1)\n        scaled = zoom(rotated, scale, order=0)\n    else:\n        scaled = white_region\n\n    new_mask = np.zeros(original_size, dtype=np.uint8)\n    \n    max_y_pos = original_size[0] - scaled.shape[0]\n    max_x_pos = original_size[1] - scaled.shape[1]\n\n    if max_y_pos > 0 and max_x_pos > 0:\n        y_pos = random.randint(0, max_y_pos)\n        x_pos = random.randint(0, max_x_pos)\n    else:\n        scale_y = original_size[0] / scaled.shape[0]\n        scale_x = original_size[1] / scaled.shape[1]\n        scale = min(scale_y, scale_x) * 1 \n        scaled = zoom(scaled, scale, order=0)\n        y_pos = random.randint(0, original_size[0] - scaled.shape[0])\n        x_pos = random.randint(0, original_size[1] - scaled.shape[1])\n\n    new_mask[y_pos:y_pos+scaled.shape[0], x_pos:x_pos+scaled.shape[1]] = scaled\n    \n    return new_mask\n\ndef edge_mask_augmentation(mask, object_mask):\n    white_pixels = np.where(mask == 1)\n    if len(white_pixels[0]) == 0:\n        return mask\n    \n    min_y, max_y = np.min(white_pixels[0]), np.max(white_pixels[0])\n    min_x, max_x = np.min(white_pixels[1]), np.max(white_pixels[1])\n    white_region = mask[min_y:max_y+1, min_x:max_x+1]\n\n    angle = random.uniform(0, 360)\n    rotated = rotate(white_region, angle, reshape=True, mode='constant', cval=0)\n    scale = random.uniform(0.6, 0.9)\n    scaled = zoom(rotated, scale, order=0)\n\n    kernel = disk(5)\n    object_edge = binary_dilation(object_mask, structure=kernel) ^ binary_erosion(object_mask, structure=kernel)\n\n    edge_coords = np.argwhere(object_edge)\n    if len(edge_coords) == 0:\n        return mask\n    target_point = edge_coords[np.random.choice(len(edge_coords))]\n\n    new_mask = np.zeros_like(mask)\n    h, w = scaled.shape\n    top_left_y = target_point[0] - h // 2\n    top_left_x = target_point[1] - w // 2\n\n    for i in range(h):\n        for j in range(w):\n            y, x = top_left_y + i, top_left_x + j\n            if (0 <= y < mask.shape[0]) and (0 <= x < mask.shape[1]) and scaled[i, j] > 0:\n                if object_mask[y, x] == 1: \n                    new_mask[y, x] = 1\n\n    return new_mask"
        }
    ]
}